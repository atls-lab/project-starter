# Инструкции для фронтенда

## Архитектура
- FSD - методология организации фронтенд-кода для понятности и устойчивости к изменениям
- слои фиксированы: `app`, `pages`, `widgets`, `features`, `entities`, `shared`; новые слои не вводить
- App и Shared не имеют слайсов; остальные слои состоят из слайсов с сегментами
- слайсы группируют код по предметной области, их имена не стандартизированы
- импорт разрешён только из слоёв с меньшей ответственностью; между слайсами одного слоя импортов нет; меньшая ответственность = ниже в цепочке: `shared` < `entities` < `features` < `widgets` < `pages` < `app`
- явные запреты по слоям: `entities` не тянут `features`, `features` не тянут `widgets`, `shared` не тянет доменку
- shared - фундамент и общие библиотеки; без бизнес-правил, флоу и сценариев, только примитивы и адаптеры
- бизнес-взаимодействия между сущностями держать на более высоких слоях (features/pages)
- разделять слой данных и UI, не смешивать их в одном файле

## Сегменты
- `ui` - всё, что связано с отображением UI: UI-компоненты, форматтеры дат, стили
- перед тем как пилить новый UI-компонент, сначала искать готовое в `ui` или `shared` слоях
- `api` - взаимодействие с бэкендом: функции запросов, типы данных, мапперы
- `model` - модель данных: схемы, интерфейсы, хранилища и бизнес-логика
- `lib` - библиотечный код, необходимый другим модулям в этом слайсе
- `config` - конфигурационные файлы и фиче-флаги
- кастомные сегменты допустимы (чаще в App и Shared), имена должны описывать назначение; `components`, `hooks`, `types` - плохие имена; примеры нормальных сегментов: `i18n`, `assets`
- не создавать сегмент `hooks`, хуки размещать по назначению в `ui`, `model` или `lib`

## Слои
- слои - первый уровень организационной иерархии, разделяют код по ответственности и зависимостям
- порядок слоёв сверху вниз по ответственности: App → Pages → Widgets → Features → Entities → Shared
- App - всё, что касается приложения целиком: маршрутизация, точки входа, глобальные стили, провайдеры
- Pages - страницы или большие части страницы при вложенном роутинге
- Widgets - крупные самодостаточные блоки интерфейса; уместны при повторном использовании или когда страница состоит из нескольких крупных блоков
- Features - повторно используемые пользовательские действия, приносящие бизнес-ценность; не всё должно быть фичей
- Entities - бизнес-сущности реального мира; слайс может включать `model`, `api`, `ui` для сущности
- Shared - фундамент приложения, связи с внешним миром и внутренние библиотеки без бизнес-логики
- App и Shared состоят из сегментов напрямую; сегменты внутри этих слоёв могут импортировать друг друга

## Документация FSD
- список всех док: https://feature-sliced.design/ru/llms.txt
- полная дока: https://feature-sliced.design/ru/llms-full.txt
- https://feature-sliced.design/ru/docs/get-started/overview
- https://feature-sliced.design/ru/docs/reference/layers
- https://feature-sliced.design/ru/docs/reference/slices-segments
- https://feature-sliced.design/ru/docs/about/understanding/architecture

## Среда
- менеджер пакетов - только yarn
- кодовая база всегда на TypeScript
- версии Node.js и пакетов брать из корневого `package.json`
- если в корневом `package.json` нет `engines.node` - ориентироваться на версию `@types/node`; если нет и её - считать версией Node.js актуальную LTS
- правила TypeScript брать из `tsconfig.json`
- для node-инструментов использовать ESM, не добавлять новый CommonJS без явного запроса

## SOLID
- S: один компонент/хук - одна ответственность; сложные сценарии дробить на мелкие
- O: расширять через композицию и выделение новых модулей, не через флаги и ветвления
- L: одинаковые контракты должны вести себя одинаково; не менять семантику пропсов «втихаря»
- I: интерфейсы держать узкими; не прокидывать универсальные пропсы «на все случаи»
- D: UI зависит от абстракций; инфраструктура подключается выше (features/model); UI и features не тащат инфраструктуру fetch/sdk/storage/analytics/http напрямую, только через адаптеры/модули в `shared`, `api`, `lib`

## Локализация
- все пользовательские тексты и форматы проводить через слой i18n
- новые строки добавлять в файлы локалей, не хардкодить тексты в компонентах

## Стили
- использовать токены дизайн-системы для цветов, типографики и отступов
- избегать фиксированных значений там, где есть токены

## Типизация
- не использовать `any`
- явно описывать типы пропсов, данных и возвращаемых значений
- `interface` - для расширяемых контрактов (public API компонентов/моделей)
- `type` - для union/utility/композиций и когда расширение не нужно
- `as SomeType` запрещён; исключение: boundary-слой (`api`/`model`) с валидацией/проверкой типов
- `unknown` ок только с явной проверкой типа
- экспортируемые типы и пропсы это контракт; не ломать без команды

## Запрещено
- сетевые запросы внутри UI-компонентов; запросы только в `api`/`model`, UI получает данные через пропсы/хуки
- хранить схему, форму и submit-логику в одном файле; схема в `model`, submit в `features`, UI в `ui`
- смешивать бизнес-логику и верстку/отображение ui в одном файле
- UI-форма не знает про флоу, редиректы и бизнес-решения; это живёт выше (features/pages/model)
- submit-хендлер из UI делает только вызов переданной функции, без условий, навигации и сайд-эффектов
- хардкод стилей: `colors`, `spaces`, `opacities` и др только из темы/токенов
- магические строки (например, URL изображений) - нельзя; брать из `src`-импортов или выносить в константы
- raw svg в коде - нельзя; svg/иконки хранить в `ui` слое и импортить как компоненты (например, `ArrowIcon`)

## Нейминг
- для директорий и файлов в основном использовать kebab-case

## Тесты
- для тестов использовать `node:test` и `node:assert`
- при добавлении логики предлагать тесты (в первую очередь `lib` тестами)
- если логика поменялась - предлагать или сразу обновлять тесты
- тест-файлы класть рядом: `fun.test.ts`
- если для тестов нужно несколько файлов - класть в `/tests/fun.test.ts`, `/tests/mocks.ts`
- моки или тест-кейсы выносить в отдельный файл

## Производительность
- избегать лишних перерисовок и тяжелых вычислений в рендере
- разбивать крупные куски UI на lazy-loading при необходимости

## SEO
- использовать семантическую разметку
- корректно заполнять мета-теги и заголовки
